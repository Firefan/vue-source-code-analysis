# vue-source-code-analysis
as repository name
# vue 与 模版

步骤

1. 编写 模版  
  1. 直接在 HTML 中写模版 [非组件]
  2. 使用 template (字符串的模版) [非组件]
  3. 以[组件的方式]，在单文件中书写 (< template />)
2. 创建Vue实例
3. 将Vue挂载到模版上(mount)，并生成真实的DOM


# 数据绑定到模版

1. 获取页面模版
2. 节点分析（类型、值、数据替换）
3. 插值替换
4. dom替换

## 后续的优化: 
1. 使用递归节点结构的分析 => 子节点：递归访问
2. 数据替换 => 对象深层属性的访问: 循环代替递归

# 虚拟DOM和DOM

1. 为什么要使用虚拟dom？？？ (使用虚拟dom是vue整个渲染跟新与数据追踪相关的)
  提升性能

2. 实现真实dom到虚拟dom
  1. 如何来描述一个dom：
    标签类型
    标签属性
    文本节点/元素节点 ==> 
      文本节点：文本的值
      元素节点：子元素 ===> 简单一点，最终的子元素节点都是文本节点 
  2. dom到虚拟dom：

## 函数柯里化

- 函数式编程

**为什么使用函数柯里化**
能将一部分东西缓存起来，于是就提升了效率，但是必然造成内存的占用
> Vue 本质上是使用 HTML 的字符串作为模版，将字符串 模版 转换为 AST， 再转换为VNode。

虚拟DOM的`render`方法: 
  - HTML模版 -> AST 
  - AST -> VNode
  - VNode -> DOM

这三个过程中，第一阶段最消耗性能，即 HTML 到 AST 的 字符串解析

    举个🌰: let s = "1 + 2 * (3 + 4)"，解析这个表达式，得到结果
    提示： 使用"波兰式"表达式，用栈结构来运算

在Vue中区分一个模版是HTML标签还是自定义的组件，就有用到函数柯里化。Vue中将所有可用的 HTML 标签先存起来了

## 虚拟DOM 的 render 方法

思考：模版转换为 抽象语法树 需要执行几次？
应该只要一次！！！
页面的模版是不会变的，改变的只是AST，修改AST就好了

*所以，应该将AST缓存在内存中，只需要传入改变的量就好了*，函数柯里化在此派上用场





